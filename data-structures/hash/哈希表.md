几乎所有的编程语言都有直接或者间接应用这种数据结构
哈希表通常是基于数组实现的,但是相对于数组,它也有很多优势
数组进行插入操作的时候,效率比较低
数组查找操作分两种情况 1.基于索引查找的话 效率非常高 2.基于内容查找的话 效率非常低
数组删除操作 效率也不高
它可以提供非常快速的 插入-删除-查找操作
无论多少数据,插入和删除值需要接近常量的时间:即 O（1）的时间级,实际上,只需要几个机器指令即可完成。
哈希表的速度比树还要快，基本上看也瞬间查找到想要的元素
哈希表相对于树来说编码要容易的多

劣势
哈希表是数据是没有顺序的,所以不能以一种固定的方式(比如说从小到大)来遍历其中的元素
通常情况下，哈希表中的 key 是不允许重复的,不能放置相同的 key,用于保存不同的元素

# 哈希化

现在需要一种压缩方法,把幂的连乘方案系统中得到巨大整数范围压缩到可接受的数组范围
哈希化: 将大数字转化为数组范围内下标的过程,我们称之为哈希化.
哈希函数:通常我们会将单词转成大数字,大数字在进行哈希化的代码实现放在一个函数中
这个函数我们称之为哈希函数

哈希表: 最终将数据插入到这个数组中,对整个结构的封装,我们称之为是一个哈希表。

解决冲突的常见的解决方案有

## 链地址法:

    链地址法解决冲突的办法就是每个数组但愿中存储的不再是单个数据,而是一个链条
    这个链条使用的数据结构 常见的是 链表和数组
    比如说链表, 也就是每个数组单元中都存储着一个链表,一旦发生重复,将重复的元素插入到链表的首端或者末端


    使用数组还是链表呢?

    效率都差不多
    因为根据哈希化的index找出这个数组或者链表时,通常就会使用线性查找

## 开放地址法 
   主要的工作方式是 寻找空白的单元格来添加重复的数据
   没有理解怎么回事,只能跳过了 后面再看吧
## 哈希化效率
  哈希表中执行插入和搜索操作的效率是非常高的
  如果没有产生冲突,那么效率就会更高
  如果发生冲突,存取事件就依赖后面的探测长度
  平均探测长度以及平均存取时间,取决于填装因子,随着填装因子变大,探测长度也越来越长。

在分析效率之前,我们先了解一个概念,装填因子

装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值
装填因子 = 总数据项/哈希表长度

开放地址法装填因子最大是  1 因为它必须找到空白单元才能够将元素放入

链地址法的装填因子 最大 可以大于1 因为拉链法可以无限衍生下去, 只要原因(当然后面的效率就变低了)

## 哈希函数

哈希表的主要优点是它的速度,所以在速度上不能满足,那么就达不到设计的目的了
提高速度的一个办法就是让哈希函数中尽量少用 乘法和除法 因为它们的性能是比较低的

设计好的哈希函数应该具备哪些优点呢?
   快速的计算
       哈希表的优势在于效率,所以快速获取到对应的hashCode 非常重要
   均匀的分步
       哈希表中,无论是链地址法还是开发地址法,当多个元素映射到同一个位置的时候,都会影响效率
       所以 优秀的哈希函数应该尽可能将元素映射到不同的位置上,让元素在哈希表中均匀分步
       因此我们需要在使用常量的地方,进行使用质数
       质数：只能被一和它自身整数的正整数  
       质数的使用:
        哈希表的长度
        N次幂的底数

### 多项式的优化  霍纳法则
    

   
